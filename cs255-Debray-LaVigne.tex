% The writeup to submit for the second milestone.
\documentclass{amsart}
\input{macros}
\begin{document}
\title{Milestone 2 Writeup}
\author{Arun Debray and Rio LaVigne\\\today}
\maketitle
In this writeup, we will illustrate that each of the functions that we implemented is secure.
% Secure Login
% password to generate a secure key
\section{Secure Login}%todo
When the user first logs in, it is prompted for a password $p$. A salt $s$ is generated using the \verb+GetRandomValues()+ function for the password and stored in local storage. Using this salt, a master key $K$ is generated with the \verb+sjcl.misc.pbkdf2()+ function, and stored in session (i.e. temporary) storage. Then, a verifier $v$ for future sessions is generated by encrypting a string with the master key; this encrypted verifier is stored in local storage.

When a returning user logs in (as determined by the existence of $s$ and $v$ in local storage), they are asked for a password $p'$. Then, the master key $K'$ corresponding to this password is generated, and the verifier $v'$ corresponding to this master key is calculated. If $v = v'$, the password is correct, and the user is let in; otherwise, the password is rejected.

To show that logging in is secure, it will be necessary to demonstrate that the user is granted access iff $p  =p'$. 

%and that they can't get the verifier otherwise...
% generate new keys
\section{The \texttt{GenerateKeys()} method}%todo
This method calls \verb+sjcl.misc.pbkdf2()+ as a PRF, accepting a 128-bit random salt and the group name as arguments. The salt is generated with the provided function \verb+GetRandomValues()+, and is therefore truly random, and \verb+sjcl.misc.pbkdf2()+ is a secure PRF under the assumption that the salt is random, so this function is secure.

% secure database for the keys
% Securely storing
% Securely loading
\section{The \texttt{SaveKeys()} and \texttt{LoadKeys()} methods}%todo
These methods rely on the same helper functions that \verb+Encrypt()+ and \verb+Decrypt()+ do; they implement the same AES-128 cipher in randomized counter mode. As discussed above, this is as secure as AES is. However, the differences are meaningful: in this case, the key is a master key generated from the password, rather than the shared group key.

Thus, if Eve knows the group key for Bob's group $G$, she cannot gain any meaningful information about the rest of Bob's encrypted groups, since they have been encrypted in randomized counter mode; the additional obstacle of the nonce prevents Eve from gaining information about the master key.

This also relies on the assumption that the master key is securely generated, which was shown in the previous section.%now things are out of order.

% encryption and decryption
\section{The \texttt{Encrypt()} and \texttt{Decrypt()} methods}%todo
These methods implement an AES-128 block cipher operating in random counter mode. Specifically, if $K$ is the key for a given group, then $E(K,m)$ is given as follows:
\begin{enumerate}
\item First, the message is padded so that its length is a multiple of $128$; then, it is chopped into $128$-bit slices: $m = m[0]\conc m[1]\conc\dots\conc m[k]$ for some $k$.
\item Then, each block is run through AES-128: $c[i] = \operatorname{AES-128}(\mathrm{IV} + i\conc K,m[i])$. The $\mathrm{IV}$ is a randomly generated nonce that is incremented with every use of the group key in a given session.
\item Then, the ciphertext is assembled from the blocks: $c = (\mathrm{IV} + i) \conc c[1] \conc c[2] \conc\dots\conc c[k]$.
\end{enumerate}
In this system, the key $K$ is used many times in a given group, but each key-nonce pair is used exactly once. Thus, this system is not vulnerable to many-time pad attacks; since the nonces are 32-bit integers, then the probability of a random collision is negligible. Thus, a successful attack on this system is equivalent to a successful attack on AES; as discussed in class, randomized counter mode is as secure as the PRP it is based upon. And since AES is believed to be secure, this system is secure.

% MAC
% authenticate group messages
% keys in the key store havenâ€™t been changed
\section{The MAC and message authentication}
Every message encrypted by this system is passed through a method that appends a MAC based on the ciphertext, in an encrypt-then-MAC protocol. The MAC used is called NMAC, which calculates the tag as follows:
\[\operatorname{NMAC}(c) = E(K_2,E(c[n],E(c[n-1],E(\dots(c[1],E(c[0],K_1))\dots)))),\]
where $E$ is the PRF used to implement AES as before and $K_1,K_2\in\cK$ are two keys generated from the secret key $K$ for the message by using AES as a PRF: $K_1 = E(K,0\conc 0\conc 0\conc 0)$ and $K_2 = E(K,1\conc 1\conc 1\conc 1)$. The ciphertext $c$ has already been padded so as to be a multiple of the block size, first by appending the size of the message, then adding zeros as necessary. Then, the sent ciphertext is $c^* = c\conc t$, the original ciphertext with the MAC attached.

When decrypting, the receiver can check the integrity of a ciphertext $c^* = c\conc t$ by removing the tag $t$ (since it is known to be of a given size) and computing $t' = \operatorname{NMAC}(c)$. If $t' = t$, then the message is validated; otherwise, an error is thrown. If the message is valid, then the padding is removed by removing all trailing zeros until the size of the message is found to yield the original ciphertext, which is then decrypted as above.

This MAC is used to ensure the authenticity of messages posted in encrypted groups (in which case $K$ is the group key) as well as to guarantee that the saved group keys have not been compromised (in which case $K$ is the overall master key).

This MAC scheme is secure: that is, it provides authenticated encryption. This will be proven in several steps:
\begin{enumerate}
\item\label{independentkeys} First, it will be shown that the two keys $K_1$ and $K_2$ are independent. Clearly, if an adversary has the generator key $K$, then it can obtain both $K_1$ and $K_2$, but if an attacker has only one of $K_1$ or $K_2$, it is not possible to recover the other derived key or $K$. If this were possible, then such an adversary could take a message-ciphertext pair $(m,c)$ (such that $c = E(K,m)$) and use it to calculate the ciphertext for some other message $m'$. However, this would imply that $E$ is vulnerable to a chosen plaintext attack, so it is not semantically secure. However, AES is believed to be semantically secure, and under that assumption, these keys cannot be derived from each other without the generator key $K$. Thus, the two keys $K_1$ and $K_2$ may be regarded as independent.
\item Next, it will be shown that NMAC is secure. It was demonstrated in class that NMAC is secure as long as the function $E$ that it calls is a secure PRF and the two keys $K_1$ and $K_2$ are independent. The former point is met because AES is assumed to be a secure PRF, which has been demonstrated in class to be a reasonable assumption, and the latter point also holds because of point~\ref{independentkeys}: $K_1$ and $K_2$ have been demonstrated to be independent. Thus, this MAC function is secure, in that existential forgeries cannot be made.

It is also necessary for the MAC function to defend against timing attacks. This is done because all comparisons are made with a comparison function that takes the same amount of time; thus, an almost completely incorrect message takes as much time to check as a nearly correct one. This prevents the adversary from using the timing of the response to learn more about the system.
\item The final point to consider is that the MAC is calculated based on the ciphertext, and in particular is added after the encryption is done; thus, it implements the encrypt-then-MAC protocol. This is the most secure option, as demonstrated in class: if the MAC is calculated based on the plaintext and not encrypted, then it can leak information about the plaintext. If the MAC is computed based on the plaintext and then encrypted (i.e. MAC-then-encrypt mode), there are a number of subtle timing attacks that make security much harder to implement. However, this mode leaks no information about the plaintext and prevents an adversary from tampering with the ciphertext (as such an attack would be detected as a MAC error).
\end{enumerate}
Thus, this MACing method provides authenticated encryption.
\section{Other questions}
%Your write-up should also discuss the following questions:
% 1. What are some of the biggest issues with doing cryptography in the browser? Why might we want to do it anyhow?
Doing cryptography in the browser is both difficult and insecure. Web development is particularly prone to conflicting standards, browsers, etc.; what works in Chrome may not work anywhere else (as in this case) and putting requirements on the user makes the cryptosystem less viable. Alternatively, different browsers might cause silent errors, encoding information insecurely (because of, for example, an incorrectly implemented random number generator). Moreover, storage is plagued by several issues: websites tend to interfere with it in unpredictable ways and thus setting up a consistent and persistent system is difficult. Additionally, the act of transmitting information over the Internet adds additional security issues: it forces the encryption scheme to depend on other protocols and systems being secure, which is not always the case: a user might be using free wireless that allows an adversary to spy on the data or even alter it, for example.

% 2. How could somebody go about circumventing the security of your implementation, if they really wanted to? (e.g. side-channel attacks)
If one wanted to break this system, there are several possible attacks. Many of these center around the user: if the adversary gains access to the master password in some manner (e.g. asking the user, intercepting it through an insecure network, or even finding an open, logged-in computer), then the entire cryptosystem is useless: the adversary can read all messages that the user as able to, impersonate the user, etc. Similarly, passwords can be compromised by attacks such as a common password attack, a dictionary attack, etc. If a user uses a common password that can be guessed, the same problems occur: with the master password, the attacker has access to all keys, and therefore can imitate the user, reading and writing messages.
%malleability
\end{document}
