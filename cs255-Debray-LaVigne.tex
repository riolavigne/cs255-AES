% The writeup to submit for the second milestone.
\documentclass{amsart}
\input{macros}
\DeclareMathOperator{\AES}{AES}
\begin{document}
\title{Milestone 2 Writeup}
\author{Rio LaVigne and Arun Debray\\\today}
\maketitle
In this writeup, we will illustrate that each of the functions that we implemented is secure.
% Secure Login
% password to generate a secure key
\section{Secure Login}
\label{securelogin}
When the user first logs in, it is prompted for a password $p$. A salt $s$ is generated using the \verb+GetRandomValues()+ function for the password and stored in local storage. Using this salt, a master key $mk$ is generated with the \verb+sjcl.misc.pbkdf2()+ function, and stored in session (i.e. temporary) storage. Then, a verifier $v$ for future sessions is generated by encrypting a known string. The encryption is done by generating a key with the master key, using AES as a PRF and encrypting the value 0. If AES is a secure PRF, the outputted key should be indistinguishable from random given a suitably random generated key from  \verb+sjcl.misc.pbkdf2()+.

When a returning user logs in (as determined by the existence of $s$ and $v$ in local storage), they are asked for a password $p'$. Then, the master key $mk'$ corresponding to this password is generated, and the verifier, $v$, saved to local storage, is decrypted again using AES as a PRF and generating the key from $\AES(mk, 0)$. If the decryption of $v$ equals the know plaintext, the password is correct, and the user is let in; otherwise, the password is rejected.

To show that logging in is secure, it will be necessary to demonstrate that the user is granted access iff $p = p'$. So, assume the user can login. This implies the user successfully decrypted the stored verifier, $E(\AES(mk, 0), v)$. Thus, the user must have either known $\AES(mk, 0)$ or $mk$. Since we assume $\AES$ is a secure PRG, we assume that $\AES(mk, 0)$ was indistinguishable from random, so $\AES(mk, 0)$ should not be able to be guessed without knowing $mk$. Now, if the user knew $mk$, this means he either knew the output of $\mathtt{sjcl.misc.pbkdf2}(p, s)$ or the correct password, $p$. If we assume the function given is secure, this implies the user must have known $p$. In the other direction, if the user enters the correct password, then the master key $mk'$ and verifier $v'$ corresponding to that password are computed from the entered password $p'$ and salt $s$. Since this computation is identical to the computation of the verifier when the password was created, and the algorithm for generating it is deterministic given the salt and password, then the verifier $v'$ must be the same as $v$, so the user is granted access.

% generate new keys
\section{The \texttt{GenerateKeys()} method}
%This method calls \verb+sjcl.misc.pbkdf2()+ as a PRF, accepting a 128-bit random salt and the group name as arguments. The salt is generated with the provided function \verb+GetRandomValues()+, and is therefore truly random, and \verb+sjcl.misc.pbkdf2()+ is a secure PRF under the assumption that the salt is random, so this function is secure.
This method uses \verb+GetRandomValues()+ to generate 128-bit pseudorandom keys. Assuming \verb+GetRandomValues()+ is a secure PRG, we have that \texttt{GenerateKeys()} generates secure pseudorandom keys.

% secure database for the keys
% Securely storing
% Securely loading
\section{The \texttt{SaveKeys()} and \texttt{LoadKeys()} methods}%todo
These methods rely on the same helper functions that \verb+Encrypt()+ and \verb+Decrypt()+ do; they implement the same AES-128 cipher in randomized counter mode. As discussed above, this is as secure as AES is. However, the differences are meaningful: in this case, the key is generated from the master key, created at login, rather than a shared group key.

So, the keys are stored in a global Javascript object while a session is active, then stringified and encrypted using the helper function \verb+encryptString+, under the key generated from again using AES-128 as a PRG with $\AES(mk, 1)$; which is a different key from the verifier. If AES is a secure PRG, then, assuming our implementation of Randomized Counter Mode is secure, the keys are stored securely with a MAC.

So, even if Eve knows the group key for one of Bob's group $G$, she cannot gain any meaningful information about the rest of Bob's encrypted groups, since they have been encrypted in randomized counter mode; the additional obstacle of the nonce prevents Eve from gaining information about the master key.

Message integrity is ensured by a MAC appended to the message; see Section~\ref{mac} for the details. This implies that an adversary cannot change the keys in a way that goes undetected.
% encryption and decryption
\section{The \texttt{Encrypt()} and \texttt{Decrypt()} methods}%todo
These methods implement an AES-128 block cipher operating in random counter mode. Specifically, if $K$ is the key for a given group, then $E(K,mString)$ is given as follows:
\begin{enumerate}
\item First, we generate 3 different keys from the group key $K$, $k0$, $k1$, and $k2$, using AES-128 as a PRG. $k0$ is used to encrypt messages directly while the other two are used to MAC. Then, we randomly generate a 96-bit IV using \verb+GetRandomValues+, and create a counter at 0.
\item The message, $mString$, is converted from UTF-8 into bits, $m$, and then fed into a loop, 128-bits at a time. It does not matter if the message is 128-bits or not, since Randomized Counter Mode works by XOR'ing the message with a nonce. The loop is as follows:
  \begin{enumerate}
    \item Take the next 128-bits of $m$ (or however many are left). Call this $m[i]$. Terminate if there are no more bits in $m$.
    \item Generate a nonce by appending the 32-bit counter with the IV, making $\mathrm{IV}\conc\operatorname{ctr}$ 128 bits. Encrypt $\mathrm{IV}\conc \mathrm{ctr}$ using $\AES$ with $k0$.
    \item XOR the encrypted nonce with $m[i]$ to get $c[i]$.
    \item Increment the counter.
  \end{enumerate}
\item After the loop, we should have a ciphertext $c = c[0] \conc \dots \conc c[n]$. We prepend the IV, $\mathrm{IV} \conc c$.
\item Then, we MAC the IV and ciphertext together to generate a tag; this ensures that we can detect if either the IV or the ciphertext has been altered. Encrypting and then generating the MAC is proven to be A.E. secure, assuming our MAC is working correctly. We prepend the tag, $t$, to get $t \conc \mathrm{IV} \conc c$ as the final ciphertext in bits.
\item The bits in $c$ are converted into base-64 characters, $cString$, and returned.
\end{enumerate}

% Do we need mroe details? Or is this too many?
Decryption works simply by reversing the process. We take the base-64 string and convert it back into bits. Then, we remove the tag and verify the MAC, then remove the IV and decrypt. If the MAC fails, we do not decrypt, but throw an error.

Additionally, message integrity is ensured by a MAC appended to the message; see Section~\ref{mac} for the full description. Thus, an adversary cannot change messages in the group without being noticed.
% authenticate group messages
% keys in the key store havenâ€™t been changed
\section{The MAC and message authentication}
\label{mac}
Every message encrypted by this system is passed through a method that appends a MAC based on the ciphertext, in an encrypt-then-MAC protocol. The MAC used is NMAC, which calculates the tag, $t$, using two keys, $k_1$ and $k_2$, and a ciphertext in bits, $c$, as follows:
\begin{enumerate}
  \item First, initialize an $\mathrm{IV}_0 = k_1$, and pad $c$ until it is a multiple of 128 bits, so that the pad-to-message length is one-to-one. This way, we can break $c$ into 128-bit chunks, $c = c[0]\conc c[1]\conc \dots \conc c[n]$.
  \item Iterate throw each chunk, $c[i]$, with the following algorithm: set a new $\mathrm{IV}_{i+1} = \mathrm{IV}_i \oplus \AES(c[i],\mathrm{IV}_i)$.
  \item Finally, encrypt $\mathrm{IV}_{n+1}$, the last IV generated from the loop, using AES with $k_2$. So, $t = \AES(k_2, \mathrm{IV}_i)$.
\end{enumerate}

When decrypting, the receiver can check the integrity of a ciphertext $c^* = t\conc c$ by removing the tag $t$ (since it is known to be of a given size) and computing $t' = \operatorname{NMAC}(c)$. If $t' = t$, then the message is validated; otherwise, an error is thrown. If the message is valid, then it is decrypted, as described earlier.

This MAC scheme is secure: that is, it provides authenticated encryption. This will be proven in a couple of steps: the NMAC implementation is secure, and the MAC is implemented in Encrypt-then-MAC fashion.
\begin{enumerate}
  \item First, an NMAC implementation is secure if it uses a secure PRF and the two keys $k_1$ and $k_2$ are independent. If we assume the AES-128 implementation given in the starter code is a secure block cipher, then AES makes a secure PRF, and is suitable for the NMAC. $k_1$ and $k_2$ are independent because they were generated, again, using the AES implementation in our code. In particular, we take the given key, $k$, in encryption and then make 3 separate keys from it using $\AES(k, 0) = k_0$, $\AES(k, 1) = k_1$, and $\AES(k, 2) = k_2$, where $k_1$ and $k_2$ are used in NMAC. Clearly, if an adversary has the generator key $K$, then it can obtain both $K_1$ and $K_2$, but if an attacker has only one of $K_1$ or $K_2$, it is not possible to recover the other derived key or $K$. If this were possible, then such an adversary could take a message-ciphertext pair $(m,c)$ (such that $c = E(K,m)$) and use it to calculate the ciphertext for some other message $m'$. However, this would imply that $E$ is vulnerable to a chosen plaintext attack, so it is not semantically secure. However, AES is believed to be semantically secure, and under that assumption, these keys cannot be derived from each other without the generator key $K$. Thus, the two keys $K_1$ and $K_2$ may be regarded as independent.
    
    It is also necessary for the MAC function to defend against timing attacks. This is done because all comparisons are made with a comparison function that takes the same amount of time, comparing bit by bit; thus, an almost completely incorrect message takes as much time to check as a nearly correct one. This prevents the adversary from using the timing of the response to learn more about the system.

  \item Second, the MAC is calculated based on the ciphertext, and in particular is added after the encryption is done; thus, it implements the encrypt-then-MAC protocol. This is the most secure option, as demonstrated in class: if the MAC is calculated based on the plaintext and not encrypted, then it can leak information about the plaintext. If the MAC is computed based on the plaintext and then encrypted (i.e. MAC-then-encrypt mode), there are a number of subtle timing attacks that make security much harder to implement. However, this mode leaks no information about the plaintext and prevents an adversary from tampering with the ciphertext (as such an attack would be detected as a MAC error).
\end{enumerate}
Thus, this MACing method provides authenticated encryption.

This MAC is used to ensure the authenticity of messages posted in encrypted groups (in which case $k$ is the group key) as well as to guarantee that the saved group keys have not been compromised (in which case $k$ is the overall master key).


\section{Other questions}
%Your write-up should also discuss the following questions:
% 1. What are some of the biggest issues with doing cryptography in the browser? Why might we want to do it anyhow?
Doing cryptography in the browser is both difficult and insecure. Web development is particularly prone to conflicting standards, browsers, etc.; what works in Chrome may not work anywhere else (as in this case) and putting requirements on the user makes the cryptosystem less viable. Alternatively, different browsers might cause silent errors, encoding information insecurely (because of, for example, an incorrectly implemented random number generator). Moreover, storage is plagued by several issues: websites tend to interfere with it in unpredictable ways and thus setting up a consistent and persistent system is difficult. The act of transmitting information over the Internet adds additional security issues: it forces the encryption scheme to depend on other protocols and systems being secure, which is not always the case: a user might be using free wireless that allows an adversary to spy on the data or even alter it, for example.

% 2. How could somebody go about circumventing the security of your implementation, if they really wanted to? (e.g. side-channel attacks)
If one wanted to break this system, there are several possible attacks. Many of these center around the user. For example, if the adversary gains access to the master password in some manner (e.g. asking the user, intercepting it through an insecure network, or even finding an open, logged-in computer), then the entire cryptosystem is useless. The adversary then can read all messages that the user was able to, impersonate the user, etc. Similarly, passwords can be compromised by attacks such as a common password attack, a dictionary attack, etc. If a user uses a common password that can be guessed, the same problems occur: with the master password, the attacker has access to all keys, and therefore can imitate the user, reading and writing messages. However, if an attacker only has access to, say, the group keys, he should not be able to derive the master key or password, since the key for encrypting keys was generated with a PRG.

As for side-channel attacks, we have protected against timing attacks on the MAC, but have...

\end{document}
