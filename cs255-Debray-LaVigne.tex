% The writeup to submit for the second milestone.
\documentclass{amsart}
\input{macros}
\begin{document}
\title{Milestone 2 Writeup}
\author{Rio LaVigne and Arun Debray\\\today}
\maketitle
In this writeup, we will illustrate that each of the functions that we implemented is secure.
% Secure Login
% password to generate a secure key
\section{Secure Login}%todo
When the user first logs in, it is prompted for a password $p$. A salt $s$ is generated using the \verb+GetRandomValues()+ function for the password and stored in local storage. Using this salt, a master key $mk$ is generated with the \verb+sjcl.misc.pbkdf2()+ function, and stored in session (i.e. temporary) storage. Then, a verifier $v$ for future sessions is generated by encrypting a known string. The encryption is done by generating a key with the master key, using AES as a PRF and encrypting the value 0. If AES is a secure PRF, the outputted key should be indistinguishable from random given a suitably random generated key from  \verb+sjcl.misc.pbkdf2()+.

When a returning user logs in (as determined by the existence of $s$ and $v$ in local storage), they are asked for a password $p'$. Then, the master key $mk'$ corresponding to this password is generated, and the verifier, $v$, saved to local storage, is decrypted again using AES as a PRF and generating the key from $AES(mk, 0)$. If the decryption of $v$ equals the know plaintext, the password is correct, and the user is let in; otherwise, the password is rejected.

To show that logging in is secure, it will be necessary to demonstrate that the user is granted access iff $p = p'$. So, assume the user can login. This implies the user successfully decrypted the stored verifier, $E(AES(mk, 0), v)$. Thus, the user must have either known $AES(mk, 0)$ or $mk$. Since we assume $AES$ is a secure PRG, we assume that $AES(mk, 0)$ was indistinguishable from random, so $AES(mk, 0)$ should not be able to be guessed without knowing $mk$. Now, if the user knew $mk$, this means he either knew the output of \verb+sjcl.misc.pbkdf2+($p$, $s$) or the correct password, $p$. If we assume the function given is secure, this implies the user must have known $p$. % Do we need the other direction?

%and that they can't get the verifier otherwise...
% generate new keys
\section{The \texttt{GenerateKeys()} method}%todo
This method uses \verb+GetRandomValues()+ to generate 128-bit pseudorandom keys. Assuming \verb+GetRandomValues()+ is a secure PRG, we have that \texttt{GenerateKeys()} generates secure pseudorandom keys.

% secure database for the keys
% Securely storing
% Securely loading
\section{The \texttt{SaveKeys()} and \texttt{LoadKeys()} methods}%todo
These methods rely on the same helper functions that \verb+Encrypt()+ and \verb+Decrypt()+ do; they implement the same AES-128 cipher in randomized counter mode. As discussed above, this is as secure as AES is. However, the differences are meaningful: in this case, the key is generated from the master key, created at login, rather than a shared group key.

So, the keys are stored in a global javascript object while a session is active, then stringified and encrypted using the helper function \verb+encryptString+, under the key generated from again using AES-128 as a PRG with $AES(mk, 1)$; which is a different key from the verifier. If AES is a secure PRG, then, assuming our implementation of Randomized Counter Mode is secure, the keys are stored securely with a MAC.

So, even if Eve knows the group key for one of Bob's group $G$, she cannot gain any meaningful information about the rest of Bob's encrypted groups, since they have been encrypted in randomized counter mode; the additional obstacle of the nonce prevents Eve from gaining information about the master key.

% encryption and decryption
\section{The \texttt{Encrypt()} and \texttt{Decrypt()} methods}%todo
These methods implement an AES-128 block cipher operating in random counter mode. Specifically, if $K$ is the key for a given group, then $E(K,mString)$ is given as follows:
\begin{enumerate}
\item First, we generate 3 different keys from the group key $K$, $k0$, $k1$, and $k2$, using AES-128 as a PRG. $k0$ is used to encrypt messages directly while the other two are used to MAC. Then, we randomly generate a 96-bit IV using \verb+GetRandomValues+, and create a counter at 0.
\item The message, $mString$, is converted from UTF-8 into bits, $m$, and then fed into a loop, 128-bits at a time. It does not matter if the message is 128-bits or not, since Randomized Counter Mode works by XOR'ing the message with a nonce. The loop is as follows:
  \begin{enumerate}
    \item Take the next 128-bits of $m$ (or however many are left). Call this $m[i]$. Terminate if there are no more bits in $m$.
    \item Generate a nonce by appending the 32-bit counter with the IV, making IV||ctr 128 bits. Encrypt IV||ctr using $AES$ with $k0$.
    \item XOR the encrypted nonce with $m[i]$ to get $c[i]$.
    \item Increment the counter.
  \end{enumerate}
\item After the loop, we should have a ciphertext $c = c[0] || \dots || c[n]$. We prepend the IV, IV || $c$.
\item Then, we MAC the IV and ciphertext together to generate a tag; this ensures that we can detect if either the IV or the ciphertext has been altered. Encrypting and then generating the MAC is proven to be A.E. secure, assuming our MAC is working correctly. We prepend the tag, $t$, to get $t$ || IV || $c$ as the final ciphertext in bits.
\item The bits in $c$ are converted into base-64 characters, $cString$, and returned.
\end{enumerate}

% Do we need mroe details? Or is this too many?

% MAC
% authenticate group messages
% keys in the key store havenâ€™t been changed
\section{The MAC and message authentication}
Every message encrypted by this system is passed through a method that appends a MAC based on the ciphertext, in an encrypt-then-MAC protocol. The MAC used is called NMAC, which calculates the tag as follows:
\[\operatorname{NMAC}(c) = E(K_2,E(c[n],E(c[n-1],E(\dots(c[1],E(c[0],K_1))\dots)))),\]
where $E$ is the PRF used to implement AES as before and $K_1,K_2\in\cK$ are two keys generated from the secret key $K$ for the message by using AES as a PRF: $K_1 = E(K,0\conc 0\conc 0\conc 0)$ and $K_2 = E(K,1\conc 1\conc 1\conc 1)$. The ciphertext $c$ has already been padded so as to be a multiple of the block size, first by appending the size of the message, then adding zeros as necessary. Then, the sent ciphertext is $c^* = c\conc t$, the original ciphertext with the MAC attached.

When decrypting, the receiver can check the integrity of a ciphertext $c^* = c\conc t$ by removing the tag $t$ (since it is known to be of a given size) and computing $t' = \operatorname{NMAC}(c)$. If $t' = t$, then the message is validated; otherwise, an error is thrown. If the message is valid, then the padding is removed by removing all trailing zeros until the size of the message is found to yield the original ciphertext, which is then decrypted as above.

This MAC is used to ensure the authenticity of messages posted in encrypted groups (in which case $K$ is the group key) as well as to guarantee that the saved group keys have not been compromised (in which case $K$ is the overall master key).

This MAC scheme is secure: that is, it provides authenticated encryption. This will be proven in several steps:
\begin{enumerate}
\item\label{independentkeys} First, it will be shown that the two keys $K_1$ and $K_2$ are independent. Clearly, if an adversary has the generator key $K$, then it can obtain both $K_1$ and $K_2$, but if an attacker has only one of $K_1$ or $K_2$, it is not possible to recover the other derived key or $K$. If this were possible, then such an adversary could take a message-ciphertext pair $(m,c)$ (such that $c = E(K,m)$) and use it to calculate the ciphertext for some other message $m'$. However, this would imply that $E$ is vulnerable to a chosen plaintext attack, so it is not semantically secure. However, AES is believed to be semantically secure, and under that assumption, these keys cannot be derived from each other without the generator key $K$. Thus, the two keys $K_1$ and $K_2$ may be regarded as independent.
\item Next, it will be shown that NMAC is secure. It was demonstrated in class that NMAC is secure as long as the function $E$ that it calls is a secure PRF and the two keys $K_1$ and $K_2$ are independent. The former point is met because AES is assumed to be a secure PRF, which has been demonstrated in class to be a reasonable assumption, and the latter point also holds because of point~\ref{independentkeys}: $K_1$ and $K_2$ have been demonstrated to be independent. Thus, this MAC function is secure, in that existential forgeries cannot be made.

  It is also necessary for the MAC function to defend against timing attacks. This is done because all comparisons are made with a comparison function that takes the same amount of time; thus, an almost completely incorrect message takes as much time to check as a nearly correct one. This prevents the adversary from using the timing of the response to learn more about the system.
\item The final point to consider is that the MAC is calculated based on the ciphertext, and in particular is added after the encryption is done; thus, it implements the encrypt-then-MAC protocol. This is the most secure option, as demonstrated in class: if the MAC is calculated based on the plaintext and not encrypted, then it can leak information about the plaintext. If the MAC is computed based on the plaintext and then encrypted (i.e. MAC-then-encrypt mode), there are a number of subtle timing attacks that make security much harder to implement. However, this mode leaks no information about the plaintext and prevents an adversary from tampering with the ciphertext (as such an attack would be detected as a MAC error).
\end{enumerate}
Thus, this MACing method provides authenticated encryption.
\section{Other questions}
%Your write-up should also discuss the following questions:
% 1. What are some of the biggest issues with doing cryptography in the browser? Why might we want to do it anyhow?
Doing cryptography in the browser is both difficult and insecure. Web development is particularly prone to conflicting standards, browsers, etc.; what works in Chrome may not work anywhere else (as in this case) and putting requirements on the user makes the cryptosystem less viable. Alternatively, different browsers might cause silent errors, encoding information insecurely (because of, for example, an incorrectly implemented random number generator). Moreover, storage is plagued by several issues: websites tend to interfere with it in unpredictable ways and thus setting up a consistent and persistent system is difficult. Additionally, the act of transmitting information over the Internet adds additional security issues: it forces the encryption scheme to depend on other protocols and systems being secure, which is not always the case: a user might be using free wireless that allows an adversary to spy on the data or even alter it, for example.

% 2. How could somebody go about circumventing the security of your implementation, if they really wanted to? (e.g. side-channel attacks)
If one wanted to break this system, there are several possible attacks. Many of these center around the user: if the adversary gains access to the master password in some manner (e.g. asking the user, intercepting it through an insecure network, or even finding an open, logged-in computer), then the entire cryptosystem is useless: the adversary can read all messages that the user as able to, impersonate the user, etc. Similarly, passwords can be compromised by attacks such as a common password attack, a dictionary attack, etc. If a user uses a common password that can be guessed, the same problems occur: with the master password, the attacker has access to all keys, and therefore can imitate the user, reading and writing messages.
%malleability
\end{document}
